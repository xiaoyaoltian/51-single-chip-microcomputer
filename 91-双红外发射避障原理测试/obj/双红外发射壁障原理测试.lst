C51 COMPILER V9.54   ______________________                                                08/26/2018 15:26:28 PAGE 1   


C51 COMPILER V9.54, COMPILATION OF MODULE ______________________
OBJECT MODULE PLACED IN .\obj\双红外发射壁障原理测试.obj
COMPILER INVOKED BY: d:\Keil_v5\C51\BIN\C51.EXE 双红外发射壁障原理测试.c OPTIMIZE(8,SPEED) BROWSE DEBUG OBJECTEXTEND PRI
                    -NT(.\obj\双红外发射壁障原理测试.lst) TABS(2) OBJECT(.\obj\双红外发射壁障原理测试.obj)

line level    source

   1          /*******************************************************************************
   2          * 版  权  : 红梅科技工作室
   3          * 论  坛  ：https://blog.csdn.net/Qingzhusshuiyun
   4          * Q Q     ：2369099714
   5          * 版权所有，盗版必究。
   6          * 工  程   : 双红外发射壁障原理测试
   7          * 文件名   : 双红外发射壁障原理测试.c
   8          * 处理器   : STC89C52RC
   9          * 编译环境 : Keil 5
  10          * 系统时钟 : 12MHZ
  11          * 版    本  : V1.0 
  12          * 生成日期  : 2018-07-31              
  13          * 修改日期  :  
  14          * 简单描述 : 通过2路红外发射，顺序接收，检测收发功能是否正常
  15                  用手遮挡对应的发射管，用共阳数码管的a、d端模拟左右2端
  16              每60ms分别检测2路发射，通过每组发射10个脉冲，如果接收到的脉冲个数大于6，表明有遮挡存在
  17          *******************************************************************************/
  18          
  19          #include<reg52.h> //包含头文件，一般情况不需要改动，头文件包含特殊功能寄存器的定义
  20          /*------------------------------------------------
  21                        硬件端口连接定义
  22          ------------------------------------------------*/
  23          
  24          #define DataPort P0 //定义数据端口 程序中遇到DataPort 则用P0 替换
  25          
  26          sbit IRSend_A=P1^2;  //定义红外发射 A
  27          sbit IRSend_B=P1^3;  //定义红外发射 B
  28          sbit IRRev =P3^2;    //接收接口
  29          
  30          
  31          bit  Flag;
  32          bit  Left_Flag;  //定义 是否存在遮挡标志位。为1表示有遮挡
  33          bit  Right_Flag;
  34          /*------------------------------------------------
  35                            函数声明
  36          ------------------------------------------------*/
  37          void Init_Timer0(void);//定时器初始化
  38          void DelayUs2x(unsigned char t);
  39          void IR_Send_Rev (void);
  40          /*------------------------------------------------
  41                              主函数
  42          ------------------------------------------------*/
  43          void main (void)
  44          {
  45   1      
  46   1        Init_Timer0();
  47   1      
  48   1      while (1)   //主循环
  49   1        {
  50   2        if(Flag)
  51   2           {
  52   3          
  53   3          IR_Send_Rev ();
  54   3      
C51 COMPILER V9.54   ______________________                                                08/26/2018 15:26:28 PAGE 2   

  55   3          if(Right_Flag)   //利用数码管的a，和d 段的亮灭表示左右遮挡情况
  56   3            DataPort |=0x08;
  57   3          else
  58   3            DataPort &=0x01;
  59   3      
  60   3            if(Left_Flag)
  61   3            DataPort |=0x01;
  62   3          else
  63   3            DataPort &=0x08;        
  64   3         }
  65   2        }
  66   1      }
  67          
  68          /*------------------------------------------------
  69                              定时器初始化子程序
  70          ------------------------------------------------*/
  71          void Init_Timer0(void)
  72          {
  73   1       TMOD |= 0x01;    //使用模式1，16位定时器，使用"|"符号可以在使用多个定时器时不受影响         
  74   1       //TH0=0x00;        //给定初值
  75   1       //TL0=0x00;
  76   1       EA=1;            //总中断打开
  77   1       ET0=1;           //定时器中断打开
  78   1       TR0=1;           //定时器开关打开
  79   1      }
  80          /*------------------------------------------------
  81                           定时器中断子程序
  82          ------------------------------------------------*/
  83          void Timer0_isr(void) interrupt 1 
  84          {
  85   1      
  86   1       TH0=(65536-60000)/256;     //重新赋值 60ms
  87   1       TL0=(65536-60000)%256;
  88   1       
  89   1       Flag=!Flag;
  90   1      
  91   1      }
  92          
  93          /*------------------------------------------------
  94           uS延时函数，含有输入参数 unsigned char t，无返回值
  95           unsigned char 是定义无符号字符变量，其值的范围是
  96           0~255 这里使用晶振12M，精确延时请使用汇编,大致延时
  97           长度如下 T=tx2+5 uS 
  98          ------------------------------------------------*/
  99          void DelayUs2x(unsigned char t)
 100          {   
 101   1       while(--t);
 102   1      }
 103          /*------------------------------------------------
 104                       2路红外发射接收函数
 105          通过每组发射10个脉冲，如果接收到的脉冲个数大于6，
 106          表明有遮挡存在，通过2路发射接收得到遮挡结果组合，
 107          可以判断障碍物位置。从而进行前进、后退、左转、右转
 108          ------------------------------------------------*/
 109          void IR_Send_Rev (void)
 110          {
 111   1      unsigned char i,pulse_num;
 112   1      
 113   1      IRSend_A=0; //关闭2个发射管
 114   1      IRSend_B=0;
 115   1      
 116   1          pulse_num=0;//清零脉冲计数 
C51 COMPILER V9.54   ______________________                                                08/26/2018 15:26:28 PAGE 3   

 117   1        for(i=0;i<10;i++)
 118   1          {
 119   2            IRSend_B=1;//打开B发射
 120   2          DelayUs2x(150);
 121   2          if(! IRRev)
 122   2                pulse_num++;
 123   2            IRSend_B=0;//关闭B发射
 124   2            DelayUs2x(150);
 125   2          }
 126   1      
 127   1        if(pulse_num>6)
 128   1           Left_Flag=1;//如果判断有障碍，点亮LED_B指示，否则熄灭
 129   1        else
 130   1           Left_Flag=0;
 131   1      
 132   1        pulse_num=0;   //脉冲计数
 133   1        for(i=0;i<10;i++)
 134   1          {
 135   2            IRSend_A=1;//打开A发射
 136   2          DelayUs2x(150);
 137   2          if(! IRRev)
 138   2              pulse_num++;
 139   2            IRSend_A=0;//关闭A发射
 140   2            DelayUs2x(150);
 141   2          }
 142   1        if(pulse_num>6)
 143   1           Right_Flag=1;//如果判断有障碍，点亮LED_A指示，否则熄灭
 144   1        else
 145   1           Right_Flag=0;
 146   1      
 147   1      
 148   1      
 149   1      
 150   1      }
 151          
 152          
 153          


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    133    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =   ----    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =      3    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
