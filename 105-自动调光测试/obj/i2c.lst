C51 COMPILER V9.54   I2C                                                                   08/26/2018 16:22:44 PAGE 1   


C51 COMPILER V9.54, COMPILATION OF MODULE I2C
OBJECT MODULE PLACED IN .\obj\i2c.obj
COMPILER INVOKED BY: d:\Keil_v5\C51\BIN\C51.EXE i2c.c OPTIMIZE(8,SPEED) BROWSE DEBUG OBJECTEXTEND PRINT(.\obj\i2c.lst) T
                    -ABS(2) OBJECT(.\obj\i2c.obj)

line level    source

   1          /*******************************************************************************
   2          * 版  权  : 红梅科技工作室
   3          * 论  坛  ：https://blog.csdn.net/Qingzhusshuiyun
   4          * Q Q     ：2369099714
   5          * 版权所有，盗版必究。
   6          * 工  程   : 自动调光测试
   7          * 文件名   : 自动调光测试.c
   8          * 处理器   : STC89C52RC
   9          * 编译环境 : Keil 5
  10          * 系统时钟 : 12MHZ
  11          * 版    本  : V1.0 
  12          * 生成日期  : 2018-08-14              
  13          * 修改日期  :  
  14          * 简单描述 : 函数是采用软件延时的方法产生SCL脉冲,固对高晶振频率要作 一定的修改....(本例是1us机器
  15              周期,即晶振频率要小于12MHZ)
  16          *******************************************************************************/  
  17                        
  18          #include "i2c.h"
  19          #include "delay.h"
  20          
  21          #define  _Nop()  _nop_()  //定义空指令
  22                                   
  23          bit ack;                //应答标志位
  24          
  25          sbit SDA=P2^1;
  26          sbit SCL=P2^0;
  27          
  28          /*------------------------------------------------
  29                              启动总线
  30          ------------------------------------------------*/
  31          void Start_I2c()
  32          {
  33   1        SDA=1;   //发送起始条件的数据信号
  34   1        _Nop();
  35   1        SCL=1;
  36   1        _Nop();    //起始条件建立时间大于4.7us,延时
  37   1        _Nop();
  38   1        _Nop();
  39   1        _Nop();
  40   1        _Nop();    
  41   1        SDA=0;     //发送起始信号
  42   1        _Nop();    //起始条件锁定时间大于4μ
  43   1        _Nop();
  44   1        _Nop();
  45   1        _Nop();
  46   1        _Nop();       
  47   1        SCL=0;    //钳住I2C总线，准备发送或接收数据
  48   1        _Nop();
  49   1        _Nop();
  50   1      }
  51          /*------------------------------------------------
  52                              结束总线
  53          ------------------------------------------------*/
  54          void Stop_I2c()
C51 COMPILER V9.54   I2C                                                                   08/26/2018 16:22:44 PAGE 2   

  55          {
  56   1        SDA=0;    //发送结束条件的数据信号
  57   1        _Nop();   //发送结束条件的时钟信号
  58   1        SCL=1;    //结束条件建立时间大于4μ
  59   1        _Nop();
  60   1        _Nop();
  61   1        _Nop();
  62   1        _Nop();
  63   1        _Nop();
  64   1        SDA=1;    //发送I2C总线结束信号
  65   1        _Nop();
  66   1        _Nop();
  67   1        _Nop();
  68   1        _Nop();
  69   1      }
  70          
  71          
  72          
  73          
  74          /*----------------------------------------------------------------
  75                           字节数据传送函数               
  76          函数原型: void  SendByte(unsigned char c);
  77          功能:  将数据c发送出去,可以是地址,也可以是数据,发完后等待应答,并对
  78               此状态位进行操作.(不应答或非应答都使ack=0 假)     
  79               发送数据正常，ack=1; ack=0表示被控器无应答或损坏。
  80          ------------------------------------------------------------------*/
  81          void  SendByte(unsigned char c)
  82          {
  83   1       unsigned char BitCnt;
  84   1       
  85   1       for(BitCnt=0;BitCnt<8;BitCnt++)  //要传送的数据长度为8位
  86   1          {
  87   2           if((c<<BitCnt)&0x80)SDA=1;   //判断发送位
  88   2             else  SDA=0;                
  89   2           _Nop();
  90   2           SCL=1;               //置时钟线为高，通知被控器开始接收数据位
  91   2            _Nop(); 
  92   2            _Nop();             //保证时钟高电平周期大于4μ
  93   2            _Nop();
  94   2            _Nop();
  95   2            _Nop();         
  96   2           SCL=0; 
  97   2          }
  98   1          
  99   1          _Nop();
 100   1          _Nop();
 101   1          SDA=1;               //8位发送完后释放数据线，准备接收应答位
 102   1          _Nop();
 103   1          _Nop();   
 104   1          SCL=1;
 105   1          _Nop();
 106   1          _Nop();
 107   1          _Nop();
 108   1          if(SDA==1)ack=0;     
 109   1             else ack=1;        //判断是否接收到应答信号
 110   1          SCL=0;
 111   1          _Nop();
 112   1          _Nop();
 113   1      }
 114          
 115          
 116          
C51 COMPILER V9.54   I2C                                                                   08/26/2018 16:22:44 PAGE 3   

 117          
 118          
 119          
 120          
 121          /*----------------------------------------------------------------
 122                           字节数据传送函数               
 123          函数原型: unsigned char  RcvByte();
 124          功能:  用来接收从器件传来的数据,并判断总线错误(不发应答信号)，
 125               发完后请用应答函数。  
 126          ------------------------------------------------------------------*/  
 127          unsigned char  RcvByte()
 128          {
 129   1        unsigned char retc;
 130   1        unsigned char BitCnt;
 131   1        
 132   1        retc=0; 
 133   1        SDA=1;             //置数据线为输入方式
 134   1        for(BitCnt=0;BitCnt<8;BitCnt++)
 135   1            {
 136   2              _Nop();           
 137   2              SCL=0;       //置时钟线为低，准备接收数据位
 138   2              _Nop();
 139   2              _Nop();      //时钟低电平周期大于4.7us
 140   2              _Nop();
 141   2              _Nop();
 142   2              _Nop();
 143   2              SCL=1;       //置时钟线为高使数据线上数据有效
 144   2              _Nop();
 145   2              _Nop();
 146   2              retc=retc<<1;
 147   2              if(SDA==1)retc=retc+1; //读数据位,接收的数据位放入retc中
 148   2              _Nop();
 149   2              _Nop(); 
 150   2            }
 151   1        SCL=0;    
 152   1        _Nop();
 153   1        _Nop();
 154   1        return(retc);
 155   1      }
 156          
 157          
 158          
 159          /*----------------------------------------------------------------
 160                               应答子函数
 161          原型:  void Ack_I2c(void);
 162           
 163          ----------------------------------------------------------------*/
 164          /*void Ack_I2c(void)
 165          {
 166            
 167            SDA=0;     
 168            _Nop();
 169            _Nop();
 170            _Nop();      
 171            SCL=1;
 172            _Nop();
 173            _Nop();              //时钟低电平周期大于4μ
 174            _Nop();
 175            _Nop();
 176            _Nop();  
 177            SCL=0;               //清时钟线，钳住I2C总线以便继续接收
 178            _Nop();
C51 COMPILER V9.54   I2C                                                                   08/26/2018 16:22:44 PAGE 4   

 179            _Nop();    
 180          }*/
 181          /*----------------------------------------------------------------
 182                               非应答子函数
 183          原型:  void NoAck_I2c(void);
 184           
 185          ----------------------------------------------------------------*/
 186          void NoAck_I2c(void)
 187          {
 188   1        
 189   1        SDA=1;
 190   1        _Nop();
 191   1        _Nop();
 192   1        _Nop();      
 193   1        SCL=1;
 194   1        _Nop();
 195   1        _Nop();              //时钟低电平周期大于4μ
 196   1        _Nop();
 197   1        _Nop();
 198   1        _Nop();  
 199   1        SCL=0;                //清时钟线，钳住I2C总线以便继续接收
 200   1        _Nop();
 201   1        _Nop();    
 202   1      }
 203          
 204          
 205          
 206          
 207          
 208          
 209          /*----------------------------------------------------------------
 210                              向无子地址器件发送字节数据函数               
 211          函数原型: bit  ISendByte(unsigned char sla,ucahr c);  
 212          功能:     从启动总线到发送地址，数据，结束总线的全过程,从器件地址sla.
 213                     如果返回1表示操作成功，否则操作有误。
 214          注意：    使用前必须已结束总线。
 215          ----------------------------------------------------------------*/
 216          /*bit ISendByte(unsigned char sla,unsigned char c)
 217          {
 218             Start_I2c();               //启动总线
 219             SendByte(sla);             //发送器件地址
 220               if(ack==0)return(0);
 221             SendByte(c);               //发送数据
 222               if(ack==0)return(0);
 223            Stop_I2c();                 //结束总线
 224            return(1);
 225          }
 226          */
 227          
 228          /*----------------------------------------------------------------
 229                              向有子地址器件发送多字节数据函数               
 230          函数原型: bit  ISendStr(unsigned char sla,unsigned char suba,ucahr *s,unsigned char no);  
 231          功能:     从启动总线到发送地址，子地址,数据，结束总线的全过程,从器件
 232                    地址sla，子地址suba，发送内容是s指向的内容，发送no个字节。
 233                     如果返回1表示操作成功，否则操作有误。
 234          注意：    使用前必须已结束总线。
 235          ----------------------------------------------------------------*/
 236          /*bit ISendStr(unsigned char sla,unsigned char suba,unsigned char *s,unsigned char no)
 237          {
 238             unsigned char i;
 239           for(i=0;i<no;i++)
 240              { 
C51 COMPILER V9.54   I2C                                                                   08/26/2018 16:22:44 PAGE 5   

 241             Start_I2c();               //启动总线
 242             SendByte(sla);             //发送器件地址
 243               if(ack==0)return(0);
 244             SendByte(suba);            //发送器件子地址
 245               if(ack==0)return(0); 
 246           
 247               SendByte(*s);            //发送数据
 248                 if(ack==0)return(0);
 249               Stop_I2c();                  //结束总线
 250             DelayMs(1);               //必须延时等待芯片内部自动处理数据完毕
 251             s++;
 252             suba++;
 253              } 
 254            return(1);
 255          }
 256          */
 257          /*----------------------------------------------------------------
 258                              向无子地址器件读字节数据函数               
 259          函数原型: bit  IRcvByte(unsigned char sla,ucahr *c);  
 260          功能:     从启动总线到发送地址，读数据，结束总线的全过程,从器件地
 261                    址sla，返回值在c.
 262                     如果返回1表示操作成功，否则操作有误。
 263          注意：    使用前必须已结束总线。
 264          ----------------------------------------------------------------*/
 265          /*bit IRcvByte(unsigned char sla,unsigned char *c)
 266          {
 267             Start_I2c();                //启动总线
 268             SendByte(sla+1);            //发送器件地址
 269               if(ack==0)return(0);
 270             *c=RcvByte();               //读取数据
 271               NoAck_I2c();              //发送非就答位
 272               Stop_I2c();               //结束总线
 273            return(1);
 274          }
 275          
 276          */
 277          /*----------------------------------------------------------------
 278                              向有子地址器件读取多字节数据函数               
 279          函数原型: bit  ISendStr(unsigned char sla,unsigned char suba,ucahr *s,unsigned char no);  
 280          功能:     从启动总线到发送地址，子地址,读数据，结束总线的全过程,从器件
 281                    地址sla，子地址suba，读出的内容放入s指向的存储区，读no个字节。
 282                     如果返回1表示操作成功，否则操作有误。
 283          注意：    使用前必须已结束总线。
 284          ----------------------------------------------------------------*/
 285          /*bit IRcvStr(unsigned char sla,unsigned char suba,unsigned char *s,unsigned char no)
 286          {
 287             unsigned char i;
 288          
 289             Start_I2c();               //启动总线
 290             SendByte(sla);             //发送器件地址
 291               if(ack==0)return(0);
 292             SendByte(suba);            //发送器件子地址
 293               if(ack==0)return(0);
 294          
 295             Start_I2c();
 296             SendByte(sla+1);
 297                if(ack==0)return(0);
 298          
 299            for(i=0;i<no-1;i++)
 300              { 
 301               *s=RcvByte();              //发送数据
 302                Ack_I2c();                //发送就答位 
C51 COMPILER V9.54   I2C                                                                   08/26/2018 16:22:44 PAGE 6   

 303               s++;
 304              } 
 305             *s=RcvByte();
 306              NoAck_I2c();                 //发送非应位
 307              Stop_I2c();                    //结束总线
 308            return(1);
 309          }
 310          */


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    152    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =   ----    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =      1    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
